[gd_scene load_steps=8 format=3 uid="uid://e44w43627nj7"]

[ext_resource type="Texture2D" uid="uid://dyw3m5lguaecy" path="res://external_ressources/textures/grass_01/T_pjwbY0_1K_B.jpg" id="1_rx1j1"]
[ext_resource type="Texture2D" uid="uid://dqvma5k7x1div" path="res://external_ressources/heightmap/Apsur/heightmap_test.res" id="2_eytp1"]

[sub_resource type="PlaneMesh" id="PlaneMesh_khqit"]
size = Vector2(25, 25)
subdivide_width = 512
subdivide_depth = 512

[sub_resource type="Shader" id="Shader_h583b"]
code = "shader_type spatial;
render_mode cull_back, diffuse_burley, specular_schlick_ggx;

uniform highp sampler2D heightmap : source_color, filter_linear_mipmap, repeat_enable;
uniform highp sampler2D noise_texture : source_color, filter_linear_mipmap, repeat_enable;
uniform highp sampler2D grass_texture : source_color, filter_linear_mipmap, repeat_enable;

uniform float _uv_scale = 1.0;
uniform float _noise_uv_scale = 1.0;
uniform vec2 _uv_offset;
uniform float _uv_rot;

// Un tableau pour stocker la géométrie locale d'un brin d'herbe
uniform vec3 grass_shape[4]; // Par exemple, 3 sommets formant un triangle
uniform float _grass_scale = 1.0;
//const grass_shape = [
    //[0.0, 0.0, 0.0],  // Base
    //[-0.05, 0.2, 0.0], // Gauche bas
    //[0.05, 0.2, 0.0],  // Droite bas
    //[0.0, 0.5, 0.0],  // Pointe centrale
//];
// Pour ajouter un effet de vent
uniform float time;

vec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {
    float sine = sin(rotation);
    float cosine = cos(rotation);

    uv -= pivot;
    uv.x = uv.x * cosine - uv.y * sine;
    uv.y = uv.x * sine + uv.y * cosine;
    uv += pivot;

    return uv;
}

mat3 rotateY(float theta)
{

	float cosa = cos(theta);
	float sina = sin(theta);


    //Y rotation
	mat3 rotate_y  = mat3(
	   vec3(cosa, 0.0, sina),
	   vec3(0.0, 1.0, 0.0),
	   vec3(-sina, 0.0, cosa)
	);

	return rotate_y;
}

void vertex() {
	vec2 cell_coords = (MODEL_MATRIX * vec4(VERTEX, 1)).xz;
	UV = cell_coords / vec2(textureSize(heightmap, 0));
	UV2 = cell_coords / vec2(textureSize(noise_texture, 0));

	float height = texture(heightmap, (UV*1.) - _uv_offset).r ;
	//float h = texture(noise_texture, UV2 * 50. * _noise_uv_scale).r * 1.5
	//	- texture(noise_texture, UV2 * 2.).r * 0.1;
	VERTEX.y = height;// + h;


    // Position originale du sommet
    vec3 vertex_position = VERTEX;

    // Utilise les coordonnées du sommet comme index dans la texture
    vec2 uv = vec2(VERTEX.x, VERTEX.z); // PlaneMesh est généralement dans le plan XZ
    vec4 grass_data = texture(noise_texture, uv);

    // Détermine la hauteur du brin d'herbe
    height = grass_data.r; // Composante rouge de la texture pour la hauteur

    // Calcule un offset pour simuler le brin d'herbe
    vec3 offset = grass_shape[VERTEX_ID % 4] * 0.1 ; // Récupère la forme du brin
    offset.y *= height * _grass_scale; // Applique la hauteur

    // Ajoute un effet de vent
    float wind = sin(uv.x * 10.0 + TIME*time) * 0.01;
    offset.x += wind;

	// random clamp
	offset.y = offset.y - texture(noise_texture, UV2 * _noise_uv_scale).r * 1.5;

    // Transforme la position finale du sommet
    VERTEX = VERTEX + offset * rotateY(_uv_rot + float(VERTEX_ID) * texture(noise_texture, UV2 * _noise_uv_scale).r);
}
//
//void vertex() {
	//vec2 cell_coords = (MODEL_MATRIX * vec4(VERTEX, 1)).xz;
	//UV = cell_coords / vec2(textureSize(heightmap, 0));
	//UV2 = cell_coords / vec2(textureSize(noise_texture, 0));
//
	//float height = texture(heightmap, (UV*_uv_scale) - _uv_offset).r ;
	//float h = texture(noise_texture, UV2 * 50. * _noise_uv_scale).r * 1.5
		//- texture(noise_texture, UV2 * 2.).r * 0.1;
	//VERTEX.y = height + h;
	//
//}


void fragment() {
	//vec3 color = texture(noise_texture, UV2 * 2.).rgb;
	vec4 grass = texture(grass_texture, rotateUV(UV2 * _uv_scale, vec2(0.5), _uv_rot));
	//if(grass.a < 0.2) discard;
	vec3 noise = texture(noise_texture, UV2 * _noise_uv_scale).rgb;
	vec3 color = grass.rgb - noise;
	ALBEDO = (vec3(0.34,0.5,0.1) - (noise * 0.4)) * 0.3 + vec3(.1, .1, .1)*0.1;//* 0.2 * vec3(.5,00.3,0.1);
	METALLIC = 0.5;
	ROUGHNESS = 0.9;
}

//void light() {
	// Called for every pixel for every light affecting the material.
	// Uncomment to replace the default light processing function with this one.
//}
"

[sub_resource type="FastNoiseLite" id="FastNoiseLite_acqx8"]
frequency = 0.3647
fractal_type = 0
fractal_octaves = 1
domain_warp_frequency = 5.74

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_g8r2a"]
seamless = true
seamless_blend_skirt = 1.0
noise = SubResource("FastNoiseLite_acqx8")

[sub_resource type="ShaderMaterial" id="ShaderMaterial_3yhqs"]
render_priority = 0
shader = SubResource("Shader_h583b")
shader_parameter/_uv_scale = 1991.16
shader_parameter/_noise_uv_scale = 1.585
shader_parameter/_uv_offset = Vector2(0.5, 0.5)
shader_parameter/_uv_rot = 0.645
shader_parameter/grass_shape = PackedVector3Array(-0.125, -28.925, 0.54, -3.115, 73.6, 1.025, 0.34, -32.705, -0.175, -0.27, -53.195, -0.045)
shader_parameter/_grass_scale = 0.2
shader_parameter/time = 2.035
shader_parameter/heightmap = ExtResource("2_eytp1")
shader_parameter/noise_texture = SubResource("NoiseTexture2D_g8r2a")
shader_parameter/grass_texture = ExtResource("1_rx1j1")

[node name="MeshInstance3D" type="MeshInstance3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.3, 0)
extra_cull_margin = 16384.0
mesh = SubResource("PlaneMesh_khqit")
surface_material_override/0 = SubResource("ShaderMaterial_3yhqs")
